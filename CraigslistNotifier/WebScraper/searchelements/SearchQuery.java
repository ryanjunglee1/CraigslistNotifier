package searchelements;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;
import java.util.HashMap;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import guielements.SearchResult;
import scraping.Item;
import scraping.WebScraper;

import org.jsoup.nodes.Attributes;

/**
 * An object that represents a user requested search based on parameters entered from the GUI, uses a 
 * search object to contain the default search conditions provided by CL and additional parameters 
 * based on options object generated by the Main GUI. Uses a webscraper object to get the base URL
 * from search object 
 * @author Arti Shala
 * @version 1.0
 * @see Item, WebScraper, Search, Options
 */
public class SearchQuery {
	private Search search;
	private String[] searchKeywordsPositive, searchKeywordsNegative;
	private String sellerType, makeSearch, modelSearch, conditionSearch; //Define sellerType and conditionSearch enum for dropdown list;
	private Boolean hasImage , multipleImagesOnly , originalImagesOnly, postedToday , searchTitlesOnly, bundleDuplicates ,
	hideAllDuplicates, hasMakeModelOnly, hasPhoneOnly, cryptoAccepted, deliveryAvailable;
	private int milerange, zipcode, descriptionLengthMin, descriptionLengthMax;
	private float minPrice, maxPrice;
	private LocalTime startDate,endDate;
	private WebScraper scraper;
	
	/**
	 * Accepts an array of keywords to search with, negative keywords to exclude, and creates a new webscraper from the default search provided
	 * Also accepts an Options Object
	 * @param keywords are the keywords to be searched for Items
	 * @param negwords are negative keywords to exclude from search
	 * @param options are the advanced search filters given by an instance of the Options object
	 * @param search is the default search that includes required parameters like area, subarea, and topic before keywords
	 * @see Options, Search
	 */
	public SearchQuery(String[] keywords, String[] negwords , Options options, Search search) {
		this.setSearchObject(search); 
		this.searchKeywordsPositive = keywords;
		this.searchKeywordsNegative = negwords;
		this.removedupekeywords();
		System.out.println("--------------Testing-------------");
		for (String s : this.searchKeywordsPositive) {
			System.out.println("Positive keyword: " + s);
		}
		for (String s : this.searchKeywordsNegative) {
			System.out.println("Negative keyword: " + s);
		}
		//this.search = new Search();
		Scanner scan = new Scanner(System.in);
		scraper = new WebScraper(search, scan);

		if (options != null) {
			HashMap<String, Boolean> checkBoxes = options.getCheckBoxes();
			HashMap<String, String> types = options.getTypes();
			minPrice = options.getMinPrice();
			maxPrice = options.getMaxPrice();
			if (checkBoxes != null) {
				hasImage = checkBoxes.get("hasImages");
				multipleImagesOnly = checkBoxes.get("multipleImagesOnly");
				originalImagesOnly = checkBoxes.get("originalImagesOnly");
				postedToday = checkBoxes.get("postedToday");
				searchTitlesOnly = checkBoxes.get("searchTitlesOnly");
				bundleDuplicates = checkBoxes.get("bundleDuplicates");
				hideAllDuplicates = checkBoxes.get("hideAllDuplicates");
				hasMakeModelOnly = checkBoxes.get("hasMakeModelOnly");
				hasPhoneOnly = checkBoxes.get("hasPhoneOnly");
				cryptoAccepted = checkBoxes.get("cryptoAccepted");
				deliveryAvailable = checkBoxes.get("deliveryAvailable");
			}

			if (types != null) {
				sellerType = types.get("sellerType");
				makeSearch = types.get("makeSearch");
				modelSearch = types.get("modelSearch"); 
				conditionSearch = types.get("conditionSearch");
			}
		}
	}
	/**
	 * Constructor for searchquery with only basic search, no Options
	 * @param keywords keywords to search with
	 * @param negwords keywords to exclude
	 * @param search basic search config
	 */
	public SearchQuery(String[] keywords, String[] negwords, Search search) {
		this(keywords, negwords, null, search);
	}
	
	/**
	 * Creates a searchresult object populated with Items that fit the search as specified by 
	 * this searchquery's Search and Options
	 * @return SearchResult object containing all the items that fit the search parameters
	 * @see updateSearch
	 */
	public SearchResult getSearch(){
		
		/*
		String baseURL = scraper.website.location();
		String[] keywordURL = new String[this.searchKeywordsPositive.length];
		ArrayList<Item> itemarraylist = new ArrayList<Item>();
		for (int i = 0; i < keywordURL.length; i++) {
			keywordURL[i] = baseURL + "query=" + this.searchKeywordsPositive[i];
			System.out.println(keywordURL[i]);
		}
		ArrayList<String> itemURL = new ArrayList<String>();
		Document[] documents = new Document[keywordURL.length];
		for (int i = 0; i < documents.length; i++) {
			try {
				documents[i] = Jsoup.connect(keywordURL[i]).get();
			} catch (IOException e) {
				System.out.println(e.getMessage());
			} catch (Exception e) {
				System.out.println(e.getMessage());
			}
			Elements rows = documents[i].getElementsByClass("rows");
			Elements resultrows = rows.get(0).children();
			for (Element resultrow : resultrows) {
				itemURL.add(resultrow.children().get(0).attributes().get("href"));
			}
			for (String s : itemURL) {
				//System.out.println(s);
				try {
					if (!s.isEmpty()) {
						Item item = new Item(s);
						if (item.isNull == false) {
							itemarraylist.add(item);
							System.out.println(item + "\n");
						}
					}
				} catch (NumberFormatException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		*/
		ArrayList<Item> itemarraylist = updateSearch();
		SearchResult results = new SearchResult(itemarraylist, this.searchKeywordsPositive[0], this);
		//results.printItems();
		return results;
	}
	
	/**
	 * The method that is actually responsible for using the WebScraper to pull all the Items from the first page of each keyword 
	 * and filter them based on Search and Options.
	 * @return ArrayList<Item> containing all the Items from the first page of each keyword search that fit the parameters
	 */
	public ArrayList<Item> updateSearch() {
		String baseURL = scraper.getWebsite().location();
		String[] keywordURL = new String[this.searchKeywordsPositive.length];
		ArrayList<Item> itemarraylist = new ArrayList<Item>();
		for (int i = 0; i < keywordURL.length; i++) {
			System.out.println("Keyword #" + i + ": " + this.searchKeywordsPositive[i]);
			if (!this.searchKeywordsPositive[i].isBlank() && this.searchKeywordsPositive.length >= 1) {
				keywordURL[i] = baseURL + "query=" + this.searchKeywordsPositive[i] + "&sort=date";
				System.out.println(keywordURL[i]);
			} else if (this.searchKeywordsPositive[i].isBlank() && this.searchKeywordsPositive.length == 1) {
				keywordURL[i] = baseURL + "&sort=date";
				System.out.println(keywordURL[i]);
			} else if (this.searchKeywordsPositive[i].isBlank() && this.searchKeywordsPositive.length > 1) {
				keywordURL[i] = "none";
				System.out.println("No keyword url added");
			}
		}
		ArrayList<String> itemURL = new ArrayList<String>();
		Document[] documents = new Document[keywordURL.length];
		for (int i = 0; i < documents.length; i++) {
			try {
				if (!keywordURL[i].equals("none")) {
					try {
						documents[i] = Jsoup.connect(keywordURL[i]).get();
					} catch (IOException e) {
						System.out.println(e.getMessage());
					} catch (Exception e) {
						System.out.println(e.getMessage());
					}
					Elements rows = documents[i].getElementsByClass("rows");
					Elements resultrows = rows.get(0).children();
					for (Element resultrow : resultrows) {
						itemURL.add(resultrow.children().get(0).attributes().get("href"));
					}
					for (String s : itemURL) {
						System.out.println(s);
						try {
							if (!s.isEmpty()) {
								Item item = new Item(s);
								try {
									if ((this.hasImage == true) && item.isHasImages() == false )
										item.setNull(true);
									if ((this.multipleImagesOnly == true) && item.isHasMultipleImages() == false)
										item.setNull(true);
									if (this.postedToday == true) {
										LocalDateTime postdate = item.getDateTimePosted();
										LocalDateTime oldestAllowed = LocalDateTime.now().minusDays(1);
										if (postdate.isBefore(oldestAllowed))
											item.setNull(true);
											System.out.println("Item invalidated!");
									}
									if (this.searchTitlesOnly == true) {
										for (String pk : this.searchKeywordsPositive) {
											if (!item.getItemName().toLowerCase().contains(pk.toLowerCase()) && !pk.isBlank()) {
												item.setNull(true);
											}
										}
									}
									if (this.hasMakeModelOnly == true) {
										System.out.println("MAKEMODELTRUE");
										if (item.getMake().isBlank() && item.getModel().isBlank())
											item.setNull(true);
									}
									if (this.bundleDuplicates == true) {
										for (Item it : itemarraylist) {
											if (item.getItemName().contentEquals(it.getItemName()) || item.getDescription().contains(it.getDescription())) {
												item.setNull(true);
											}
										}
									}
									if (this.hideAllDuplicates == true) {
										ArrayList<Item> scheduledforremoval = new ArrayList<Item>();
										for (Item it : itemarraylist) {
											if (item.getItemName().contentEquals(it.getItemName()) || item.getDescription().contentEquals(it.getDescription())) {
												item.setNull(true);
												scheduledforremoval.add(it);
											}
										}
										for (Item r : scheduledforremoval) {
											itemarraylist.remove(r);
										}
									}
									if (this.searchKeywordsNegative.length != 0) {
										for (String p : this.searchKeywordsNegative) {
											if (this.searchTitlesOnly == true) {
												if (item.getItemName().toLowerCase().contains(p.toLowerCase())) {
													item.setNull(true);
												}
											}
											else {
												if (item.getItemName().toLowerCase().contains(p.toLowerCase()) || item.getDescription().toLowerCase().contains(p.toLowerCase())) {
													item.setNull(true);
												}
											}
										}
											
									}
								} catch (NullPointerException e) {
									
								}
								if (item.isNull() == false && this.maxPrice >= this.minPrice && item.getItemPrice() >= this.minPrice && item.getItemPrice() <= this.maxPrice) {
									
									itemarraylist.add(item);
									System.out.println(item + "\n");
								}
							}
						} catch (NumberFormatException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				} else {
					
				}
			} catch (NullPointerException e) {
				System.out.println("NullPointerException: ");
				for (String s : this.searchKeywordsPositive) {
					System.out.println("Positive keyword: " + s);
				}
				for (String s : this.searchKeywordsNegative) {
					System.out.println("Negative keyword: " + s);
				}
				for (String s : keywordURL) {
					System.out.println("Keyword URL: " + s);
				}
			}
		}
		return itemarraylist;
	}
	
	/**
	 * Used for testing purposes only, allows user to create a basic search using the console
	 * @return a user created Search Object
	 */
	public static Search newSearch() {
		Scanner scan = new Scanner(System.in);
    	Search search = new Search();

    	System.out.println("Choose from a list of States:");
        for (String state: search.getStateMap().keySet()) {
        	System.out.print(state + "\t");
        }
        String stateInput = scan.nextLine();
        search = new State(stateInput);

        if (search.hasArea()) {
        	System.out.println("Choose from a list of Areas:");
        	for (String area: search.getAreaMap().keySet()) {
        		System.out.print(area + "\t");
        	}
        	String areaInput = scan.nextLine();
        	search = new Area(search, areaInput);
        }

        if (search.hasSubArea()) {
        	System.out.println("Choose from a list of Sub Areas:");
        	for (String subArea: search.getSubAreaMap().keySet()) {
        		System.out.print(subArea + "\t");
        	}
        	String subAreaInput = scan.nextLine();
        	search = new SubArea(search, subAreaInput);
        }

        System.out.println("Choose from a list of Topics:");
        for (String topic: search.getTopicMap().keySet()) {
        	System.out.print(topic + "\t");
        }
       	String topicInput = scan.nextLine();
       	search = new Topic(search, topicInput);

       	System.out.println("Choose from a list of Categories:");
       	for (String category: search.getCategoryMap().keySet()) {
        	System.out.print(category + "\t");
        }
       	String categoryInput = scan.nextLine();
       	search = new Category(search, categoryInput);
       	return search;
	}
	
	/**
	 * Removes all duplicate keywords, whether negative or positive, that exist in this object
	 */
	public void removedupekeywords() {
		if (this.searchKeywordsPositive.length > 1) {
			ArrayList<String> poslist = new ArrayList<String>();
			for (String s : this.searchKeywordsPositive) {
				if (!poslist.contains(s)) {
					poslist.add(s);
				}
			}
			for (String s : poslist) {
				System.out.println("poslist: " + s);
			}
			this.searchKeywordsPositive = poslist.toArray(new String[0]);
		}
		if (this.searchKeywordsNegative.length > 1) {
			ArrayList<String> neglist = new ArrayList<String>();
			for (String s : this.searchKeywordsNegative) {
				if (!neglist.contains(s)) {
					neglist.add(s);
				}
			}
			for (String s : neglist) {
				System.out.println("neglist: " + s);
			}
			this.searchKeywordsNegative = neglist.toArray(new String[0]);
			
		}
	}
	
	
	public static void main(String[] args) {
		/*
		String[] testkeywords = {"Ford", "Audi", "Toyota"};
		SearchQuery q = new SearchQuery(testkeywords, newSearch());
		q.getSearch();
		*/
		//SearchQuery query = new SearchQuery(testkeywords);
		//SearchResult result = query.getSearch();
		//result.printItems();
	}

	/**
	 * @return the search
	 */
	public Search getSearchObject() {
		return search;
	}

	/**
	 * @param search the search to set
	 */
	public void setSearchObject(Search search) {
		this.search = search;
	}
	
}
